# -*- coding: utf-8 -*-
import os
import sys
import json
import random
import tkinter as tk
from tkinter import messagebox
from datetime import datetime, date, timedelta

# -------------------- 경로 설정 --------------------
# PyInstaller로 빌드되면 sys._MEIPASS에 내장 데이터들이 풀려 있음
if getattr(sys, "frozen", False):
    # exe가 풀려서 실행되는 임시 폴더 (내장된 questions.json 위치)
    DATA_DIR = sys._MEIPASS
    # 실제 exe 파일이 있는 폴더
    BASE_DIR = os.path.dirname(sys.executable)
else:
    # 파이썬 스크립트로 실행할 때
    BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    DATA_DIR = BASE_DIR

# 문제 파일: exe 안에 포함된 questions.json 또는 .py 옆에 있는 questions.json
QUESTIONS_FILE = os.path.join(DATA_DIR, "questions.json")

# 결과 저장 위치 설정
# - 윈도우: C:\Users\사용자\AppData\Roaming\OX_Quiz_Results
# - 그 외: 실행 파일(.py / .exe) 옆에 results 폴더
if os.name == "nt":
    appdata = os.getenv("APPDATA")  # 예: C:\Users\CMuser\AppData\Roaming
    if appdata:
        RESULTS_DIR = os.path.join(appdata, "OX_Quiz_Results")
    else:
        RESULTS_DIR = os.path.join(BASE_DIR, "results")
else:
    RESULTS_DIR = os.path.join(BASE_DIR, "results")


class QuizApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title("OX Quiz (거만 모드)")
        self.geometry("700x450")

        # 데이터
        self.questions = []          # 전체 문제 리스트 (list[dict])
        self.current_list = []       # 현재 풀이 중인 문제 리스트
        self.current_index = 0
        self.mode = None             # "normal" or "review"

        # UI 요소
        self.main_frame = None
        self.quiz_frame = None
        self.question_var = tk.StringVar()
        self.choices_var = tk.StringVar()
        self.status_var = tk.StringVar()

        # 결과 폴더 생성
        if not os.path.exists(RESULTS_DIR):
            os.makedirs(RESULTS_DIR, exist_ok=True)

        # UI 구성
        self.create_main_menu()
        self.create_quiz_screen()

        self.show_main_menu()

    # -------------------- 공통 유틸 --------------------

    def get_today_str(self) -> str:
        return date.today().strftime("%Y-%m-%d")

    def load_questions(self):
        """
        questions.json을 읽어서 self.questions에 저장.
        - OX 형식: { "subject": "...", "question": "...", "answer": "O" 또는 "X" }
          (type 없으면 자동으로 OX로 본다)
        - 객관식 형식:
          {
            "subject": "...",
            "type": "MC",
            "question": "...",
            "choices": ["보기1", "보기2", "보기3", "보기4"],
            "answer_index": 0   # 0부터 시작
          }
        """
        if not os.path.exists(QUESTIONS_FILE):
            messagebox.showerror(
                "오류",
                f"문제 파일이 없다. 이걸로 뭘 풀겠다는 거냐.\n\n경로: {QUESTIONS_FILE}"
            )
            self.questions = []
            return

        try:
            with open(QUESTIONS_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
        except Exception as e:
            messagebox.showerror(
                "오류",
                f"문제 파일 불러오다가 에러 났다.\n에러나 고치고 와라.\n\n{e}"
            )
            self.questions = []
            return

        if not isinstance(data, list):
            messagebox.showerror(
                "오류",
                "questions.json 형식이 리스트가 아니다. 형식부터 바로 잡고 와라."
            )
            self.questions = []
            return

        valid_questions = []

        for item in data:
            if not isinstance(item, dict):
                continue

            q_text = item.get("question")
            if not isinstance(q_text, str):
                continue

            subject = item.get("subject")
            qtype = item.get("type")

            # ----- 객관식 (MC) 처리 -----
            # type == "MC" 이거나, choices + answer_index가 있으면 객관식으로 간주
            if qtype == "MC" or ("choices" in item and "answer_index" in item):
                choices = item.get("choices")
                answer_index = item.get("answer_index")

                if not isinstance(choices, list) or len(choices) < 2:
                    # 보기도 제대로 안 넣어놓으면 버린다
                    continue
                if not isinstance(answer_index, int) or not (0 <= answer_index < len(choices)):
                    # 정답 인덱스도 엉망이면 버린다
                    continue

                valid_item = {
                    "question": q_text,
                    "qtype": "MC",
                    "choices": choices,
                    "answer_index": answer_index
                }
                if subject is not None:
                    valid_item["subject"] = subject

                valid_questions.append(valid_item)
                continue

            # ----- OX 처리 -----
            a = item.get("answer")
            if not (isinstance(a, str) and a.upper() in ("O", "X")):
                # OX인데 답도 제대로 안 넣어놨으면 패스
                continue

            valid_item = {
                "question": q_text,
                "qtype": "OX",
                "answer": a.upper()
            }
            if subject is not None:
                valid_item["subject"] = subject

            valid_questions.append(valid_item)

        if not valid_questions:
            messagebox.showerror(
                "오류",
                "쓸 만한 문제가 한 개도 없다.\nquestions.json 내용부터 제대로 채워와라."
            )

        self.questions = valid_questions

    def save_result(self, question_dict, user_answer, correct_answer, is_correct):
        """결과를 오늘 날짜 파일에 저장."""
        today_str = self.get_today_str()
        filename = os.path.join(RESULTS_DIR, f"results_{today_str}.json")

        if os.path.exists(filename):
            try:
                with open(filename, "r", encoding="utf-8") as f:
                    data = json.load(f)
            except Exception:
                data = {"correct": [], "wrong": []}
        else:
            data = {"correct": [], "wrong": []}

        record = {
            "question": question_dict.get("question", ""),
            "correct_answer": correct_answer,
            "user_answer": user_answer,
            "is_correct": is_correct,
            "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "subject": question_dict.get("subject"),
            "qtype": question_dict.get("qtype", "OX")
        }

        if is_correct:
            data.setdefault("correct", []).append(record)
        else:
            data.setdefault("wrong", []).append(record)

        try:
            with open(filename, "w", encoding="utf-8") as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            messagebox.showerror(
                "오류",
                f"결과 저장도 제대로 못 했다.\n에러나 보고 와라.\n\n{e}"
            )

    def collect_recent_wrong_questions(self):
        """최근 7일간 results 파일에서 오답만 모아서
        self.questions와 매칭되는 문제 리스트를 반환."""
        if not self.questions:
            self.load_questions()

        bank_map = {q["question"]: q for q in self.questions}

        today = date.today()
        unique_wrong = {}

        for i in range(7):
            d = today - timedelta(days=i)
            filename = os.path.join(RESULTS_DIR, f"results_{d.strftime('%Y-%m-%d')}.json")
            if not os.path.exists(filename):
                continue

            try:
                with open(filename, "r", encoding="utf-8") as f:
                    data = json.load(f)
            except Exception:
                continue

            for item in data.get("wrong", []):
                q_text = item.get("question")
                if not q_text:
                    continue
                if q_text in bank_map and q_text not in unique_wrong:
                    unique_wrong[q_text] = bank_map[q_text]

        return list(unique_wrong.values())

    # -------------------- 오답 팝업 --------------------

    def show_wrong_popup(self, msg: str):
        """프로그램 창 안쪽에서만 뜨는 커스텀 오답 팝업."""
        popup = tk.Toplevel(self)
        popup.title("틀렸다")
        popup.resizable(False, False)

        label = tk.Label(popup, text=msg, font=("맑은 고딕", 12))
        label.pack(padx=20, pady=15)

        btn = tk.Button(
            popup,
            text="다시 풀어봐",
            font=("맑은 고딕", 11),
            command=popup.destroy
        )
        btn.pack(pady=(0, 15))

        popup.update_idletasks()

        # 부모 창 기준 중앙 배치
        self.update_idletasks()
        root_x = self.winfo_rootx()
        root_y = self.winfo_rooty()
        root_w = self.winfo_width()
        root_h = self.winfo_height()

        win_w = popup.winfo_width()
        win_h = popup.winfo_height()

        x = root_x + (root_w - win_w) // 2
        y = root_y + (root_h - win_h) // 2

        # 부모 영역 안에서만 보이도록 보정
        if x < root_x:
            x = root_x
        if y < root_y:
            y = root_y
        if x + win_w > root_x + root_w:
            x = root_x + root_w - win_w
        if y + win_h > root_y + root_h:
            y = root_y + root_h - win_h

        popup.geometry(f"+{x}+{y}")

        popup.transient(self)
        popup.grab_set()
        self.wait_window(popup)

    # -------------------- UI: 메인 메뉴 --------------------

    def create_main_menu(self):
        self.main_frame = tk.Frame(self)

        title_label = tk.Label(
            self.main_frame,
            text="OX Quiz (건축직 훈련소)",
            font=("맑은 고딕", 18, "bold")
        )
        title_label.pack(pady=20)

        btn_start = tk.Button(
            self.main_frame,
            text="문제 풀기",
            font=("맑은 고딕", 14),
            width=15,
            command=self.start_normal_mode
        )
        btn_start.pack(pady=10)

        btn_review = tk.Button(
            self.main_frame,
            text="오답 풀기",
            font=("맑은 고딕", 14),
            width=15,
            command=self.start_review_mode
        )
        btn_review.pack(pady=10)

        btn_quit = tk.Button(
            self.main_frame,
            text="종료",
            font=("맑은 고딕", 12),
            width=10,
            command=self.destroy
        )
        btn_quit.pack(pady=20)

    def show_main_menu(self):
        self.quiz_frame.pack_forget()
        self.main_frame.pack(fill="both", expand=True)
        self.status_var.set("")
        self.choices_var.set("")

    # -------------------- UI: 문제 풀이 화면 --------------------

    def create_quiz_screen(self):
        self.quiz_frame = tk.Frame(self)

        lbl_q = tk.Label(
            self.quiz_frame,
            textvariable=self.question_var,
            font=("맑은 고딕", 16),
            wraplength=650,
            justify="center"
        )
        lbl_q.pack(pady=(30, 10))

        # 객관식 보기 출력용
        lbl_choices = tk.Label(
            self.quiz_frame,
            textvariable=self.choices_var,
            font=("맑은 고딕", 13),
            wraplength=650,
            justify="left"
        )
        lbl_choices.pack(pady=(0, 10))

        # OX 버튼 프레임
        self.btn_frame_ox = tk.Frame(self.quiz_frame)

        btn_o = tk.Button(
            self.btn_frame_ox,
            text="O",
            font=("맑은 고딕", 18, "bold"),
            width=5,
            height=2,
            command=lambda: self.handle_answer("O")
        )
        btn_o.pack(side="left", padx=20)

        btn_x = tk.Button(
            self.btn_frame_ox,
            text="X",
            font=("맑은 고딕", 18, "bold"),
            width=5,
            height=2,
            command=lambda: self.handle_answer("X")
        )
        btn_x.pack(side="left", padx=20)

        # 객관식 버튼 프레임 (최대 4지선다 기준)
        self.btn_frame_mc = tk.Frame(self.quiz_frame)
        self.mc_buttons = []
        for i in range(4):
            btn = tk.Button(
                self.btn_frame_mc,
                text=f"{i+1}",
                font=("맑은 고딕", 16, "bold"),
                width=4,
                height=2,
                command=lambda idx=i: self.handle_answer(idx)
            )
            btn.pack(side="left", padx=10)
            self.mc_buttons.append(btn)

        lbl_status = tk.Label(
            self.quiz_frame,
            textvariable=self.status_var,
            font=("맑은 고딕", 12)
        )
        lbl_status.pack(pady=10)

        btn_back = tk.Button(
            self.quiz_frame,
            text="메인 화면으로",
            font=("맑은 고딕", 12),
            command=self.show_main_menu
        )
        btn_back.pack(pady=10)

    def start_normal_mode(self):
        self.load_questions()
        if not self.questions:
            messagebox.showinfo(
                "알림",
                "문제도 없이 뭘 풀겠다는 거냐.\nquestions.json부터 채우고 다시 와라."
            )
            return

        self.mode = "normal"
        self.current_list = self.questions[:]
        random.shuffle(self.current_list)
        self.current_index = 0
        self.status_var.set("")
        self.main_frame.pack_forget()
        self.quiz_frame.pack(fill="both", expand=True)
        self.show_current_question()

    def start_review_mode(self):
        wrong_questions = self.collect_recent_wrong_questions()
        if not wrong_questions:
            messagebox.showinfo(
                "알림",
                "최근 7일 동안 틀린 것도 없다.\n잘난 척은 해도 되겠는데, 오답 풀 건 없다."
            )
            return

        self.mode = "review"
        self.current_list = wrong_questions
        random.shuffle(self.current_list)
        self.current_index = 0
        self.status_var.set("최근 7일 오답만 다시 풀어봐라.")
        self.main_frame.pack_forget()
        self.quiz_frame.pack(fill="both", expand=True)
        self.show_current_question()

    def show_current_question(self):
        if not self.current_list:
            self.question_var.set("문제가 없다. 데이터부터 챙겨와라.")
            self.choices_var.set("")
            self.btn_frame_ox.pack_forget()
            self.btn_frame_mc.pack_forget()
            return

        if self.current_index < 0 or self.current_index >= len(self.current_list):
            self.question_var.set("더 이상 풀 문제 없다.")
            self.choices_var.set("")
            self.btn_frame_ox.pack_forget()
            self.btn_frame_mc.pack_forget()
            return

        q = self.current_list[self.current_index]
        self.question_var.set(q.get("question", ""))

        qtype = q.get("qtype", "OX")

        if qtype == "MC":
            # 객관식: 보기 출력 + 객관식 버튼 보이기
            choices = q.get("choices", [])
            lines = []
            for idx, choice in enumerate(choices):
                lines.append(f"{idx+1}) {choice}")
            self.choices_var.set("\n".join(lines))

            # 버튼 개수 조절 (choices 길이까지만 표시)
            for i, btn in enumerate(self.mc_buttons):
                if i < len(choices):
                    btn.config(text=f"{i+1}")
                    btn.pack(side="left", padx=10)
                else:
                    btn.pack_forget()

            self.btn_frame_ox.pack_forget()
            self.btn_frame_mc.pack(pady=10)
        else:
            # OX: 보기 텍스트 없음 + OX 버튼 보이기
            self.choices_var.set("")
            self.btn_frame_mc.pack_forget()
            self.btn_frame_ox.pack(pady=10)

    def goto_next_question(self):
        """정답일 때 0.5초 뒤에 호출해서 다음 문제로 넘기는 함수."""
        self.current_index += 1
        if self.current_index >= len(self.current_list):
            messagebox.showinfo(
                "알림",
                "더 풀 문제 없다.\n메인 화면으로 쫓아보낸다."
            )
            self.show_main_menu()
        else:
            self.status_var.set("")  # 다음 문제에서 상태 문구 초기화
            self.show_current_question()

    def handle_answer(self, user_answer):
        """
        user_answer:
          - OX 문제: "O" 또는 "X"
          - 객관식: 선택한 보기 인덱스 (0, 1, 2, 3 ...)
        """
        if not self.current_list:
            return

        q = self.current_list[self.current_index]
        qtype = q.get("qtype", "OX")

        if qtype == "MC":
            # 객관식 처리
            choices = q.get("choices", [])
            correct_index = q.get("answer_index")

            if not isinstance(correct_index, int) or correct_index < 0 or correct_index >= len(choices):
                # 문제 데이터가 잘못돼 있으면 그냥 틀린 걸로 치고 넘어간다.
                is_correct = False
                correct_answer_str = ""
                user_answer_str = ""
            else:
                is_correct = (user_answer == correct_index)

                def choice_text(idx):
                    if isinstance(idx, int) and 0 <= idx < len(choices):
                        return choices[idx]
                    return ""

                correct_answer_str = choice_text(correct_index)
                user_answer_str = choice_text(user_answer)

            # 결과 저장
            self.save_result(q, user_answer_str, correct_answer_str, is_correct)

        else:
            # OX 처리
            correct_answer = str(q.get("answer", "")).upper()
            user_answer_str = str(user_answer).upper()
            is_correct = (user_answer_str == correct_answer)
            correct_answer_str = correct_answer

            # 결과 저장
            self.save_result(q, user_answer_str, correct_answer_str, is_correct)

        if is_correct:
            # 정답: 상태 문구 표시 후 0.5초 뒤에 다음 문제로 이동
            self.status_var.set("정답이다. 이제 좀 하는데?")
            self.after(500, self.goto_next_question)
        else:
            # 오답: 팝업 + 같은 문제 다시 선택
            self.status_var.set("오답이다. 머리 식히고 다시 골라봐라.")

            msg_list = [
                "틀렸어 짜식아~",
                "어허, 이건 아니지.",
                "슷.",
                "이렇게 해선 내가 도움을 줄 수가 없어.",
                "죽는다 진짜.",
                "다시.",
                "또 다시.",
                "한 번 더."
            ]
            msg = random.choice(msg_list)

            self.show_wrong_popup(msg)
            # current_index 그대로 두고 같은 문제 반복


if __name__ == "__main__":
    app = QuizApp()
    app.mainloop()
